### Fragment Traversal with Parameters
## updated Mon 06-16 11:22:24 -0700

Traverse(ScenarioID)
{
  // The top-level entry for fragment traversal.
  // first things first: don't re-compute if there is cached data

  if ~isempty( SELECT * FROM NodeCache WHERE FragmentID = @FragmentID AND
  ScenarioID = @ScenarioID AND NodeWeight ~=0 ) 
    return // do not re-compute 

  myflows = this.flows; // (I have no idea what language I'm writing)
    
  myflows = applyDependencyParam ( myflows, ScenarioID );
  
  // fpflows now has an additional field from FlowFlowProperty.MeanValue
  fpflows = applyFlowPropertyParam ( myflows, ScenarioID );

  RootNode = ReferenceFlow.FragmentFlowID;
  float activity = 1;
  
  // traverse the tree recursively, writing cache values as you go
  node_recurse(fpflows, ScenarioID, RootNode, activity);
  // DONE.
}


e=applyDependencyParam(flows,ScenarioID)
{
  // This function returns modified flows table that contains
  // scenario-specific parameterization for dependency relationships

  ParamList params = ScenarioParam.* WHERE ScenarioID = @ScenarioID
  	    	     		     AND FragmentID = @FragmentID
  dep_params = INNER JOIN params->Param->DependencyParam // types 1, 2, 3
  
  // generate scenario-specific edge table.  The idea is that we use the
  // edge weights specified in the default FragmentEdge table, unless they
  // have been overridden by scenario params
  e = SELECT flows.*,
      dep_params.Value AS ParamValue,
      FROM flows 
      LEFT OUTER JOIN dep_params ON FragmentFlowID
        
  // take the param values as defaults:
  UPDATE e.Quantity with e.ParamValue where e.ParamValue is not null;

  DROP field ParamValue; // so e has the same fields as flows

  return e;
}

fp_flows=applyFlowPropertyParam(flows,ScenarioID)
{
  // This function returns an augmented flows table that includes
  // a field containing the FlowFlowProperty.MeanValue field that
  // matches both FlowID and FlowPropertyID in each flows record.
  // also applies scenario-specific flow property parameterization.

  // first, determine the correct FlowFlowPropertyID
  fp_flows = SELECT flows.*,
  	     ffp.MeanValue
	     FROM flows INNER JOIN FlowFlowProperty ffp
  	     ON flows.FlowID = ffp.FlowID
	     WHERE flows.FlowPropertyID = ffp.FlowPropertyID
  
  // next, see if there are any relevant flow property params
  ParamList params = ScenarioParam.* WHERE ScenarioID = @ScenarioID
  	    	     		     AND FragmentID = @FragmentID
  fp_params = INNER JOIN params->Param->FlowPropertyParam // type 4
  
  // then attach the param values (if there are any) to fp_flows
  fp_flows = SELECT fp_flows.*,
      	     fp_params.Value AS ParamValue,
      	     FROM fp_flows 
      	     LEFT OUTER JOIN fp_params 
	     ON fp_flows.FlowFlowPropertyID = fp_params.FlowFlowPropertyID
        
  // take the param values as defaults:
  UPDATE fp_flows.MeanValue with fp_flows.ParamValue 
  	 where fp_flows.ParamValue is not null;

  DROP field ParamValue; 

  return fp_flows;
}


Fragment.node_recurse(flows, ScenarioID, current_flow, activity)
{
  the_flow = SELECT * FROM flows WHERE FragmentFlowID = current_flow

  // "enter" the node -- handle reference property conversion
  // (params of type 4 have effect here)
  node_weight = the_flow.Quantity;
  node_conv = the_flow.MeanValue;

  activity = activity * node_weight * node_conv; % node activity level unit conversion

  SetNodeCache( current_flow, ScenarioID, activity )
  
  // now descend into node's children
  switch the_flow.NodeType
    case 'Process'
    {
      // dependencies are encoded in the edge table
      dependencies = SELECT * FROM flows WHERE ParentFragmentFlowID = current_flow
      for i in dependencies
      { 
        node_recurse(flows, ScenarioID, i.FragmentFlowID, activity )
      }
    }
    case 'Fragment'
    { 
      // dependencies are inputs and outputs from subfragment
      the_node = SELECT * FROM the_flow INNER JOIN FragmentNodeFragment fnf
      	       	 ON the_flow.FragmentNodeID = fnf.FragmentNodeID
      
      // flows in current fragment that depend on this node
      dependencies = SELECT * FROM flows
      		     WHERE flows.ParentFragmentFlowID = current_flow;

      F = new Fragment(the_node.SubFragmentID);

      // traverse the subfragment
      F.Traverse(ScenarioID);

      // need to set current fragment quantities based on subfragment 
      // inputs and outputs
      F.map_dependencies(dependencies);

      /*
      // IOFlows is a list of edges.  For every edge that has a
      // corresponding entry in our local edge table, follow it.  
      IOFlows = F.InputOutput(ScenarioID)
      dependencies = MatchDependencies(flows,IOFlows); 
      */


      for i in dependencies
      { 
        node_recurse(flows, ScenarioID, i.ParentFragmentFlowID, activity )
      }

    }
    case Background
      // nothing to do -- background fragments have already been traversed

    case InputOutput
      // nothing to do -- cache value specifies input/output quantity

  end // switch NodeType
}

Fragment.map_dependencies( dep )
{
  // match local input-output flows to remote dependencies
  // flows = this fragment
  // dependencies = remote fragment

  my_IO = SELECT FlowID, 
  	         DirectionID, 
		 sum( Quantity ) AS IOsum
	  FROM flows
	  WHERE flows.NodeType = 'InputOutput'
	  GROUP BY FlowID, DirectionID;

  dep = CompDir( dep ); // create a new field CompDirID which reverses the
      		     	// sense of DirectionID: 
      		     	// 'Input' becomes 'Output' and vice versa

  // some error checking here-- dep records should match my_IO records
  // exactly on FlowID and Direction / CompDir
 
  dep = SELECT dep.*,
  	       my_IO.IOsum
	FROM dep
	INNER JOIN my_IO ON dep.FlowID = my_IO.FlowID
	WHERE dep.CompDirID = my_IO.DirectionID


  UPDATE dep.Quantity WITH dep.IOsum
}
