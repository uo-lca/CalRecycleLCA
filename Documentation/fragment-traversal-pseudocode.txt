### Fragment Traversal with Parameters
## updated Mon 06-16 11:22:24 -0700

Traverse(ScenarioID)
{
  // The top-level entry for fragment traversal.
  // first things first: don't re-compute if there is cached data

  if ~isempty( SELECT * FROM NodeCache WHERE FragmentID = @FragmentID AND
  ScenarioID = @ScenarioID) 
    return // do not re-compute 

  myflows = this.flows; 
    
  myflows = applyDependencyParam ( myflows, ScenarioID );
  
  // fpflows now has an additional field from FlowFlowProperty.MeanValue
  fpflows = applyFlowPropertyParam ( myflows, ScenarioID );

  float RootNode = ReferenceFlow.FragmentFlowID;
  float activity = 1;
  
  // traverse the tree recursively, writing cache values as you go
  node_recurse(fpflows, ScenarioID, RootNode, activity);
  // DONE.
}


e=applyDependencyParam(flows,ScenarioID)
{
  // This function returns modified flows table that contains
  // scenario-specific parameterization for dependency relationships

  ParamList params = ScenarioParam.* WHERE ScenarioID = @ScenarioID
  	    	     		     AND FragmentID = @FragmentID
  dep_params = INNER JOIN params->Param->DependencyParam // types 1, 2, 3
  
  // generate scenario-specific edge table.  The idea is that we use the
  // edge weights specified in the default FragmentEdge table, unless they
  // have been overridden by scenario params
  e = SELECT flows.*,
      edge_params.Value AS ParamValue,
      FROM flows 
      LEFT OUTER JOIN edge_params ON FragmentFlowID
        
  // take the param values as defaults:
  UPDATE e.Quantity with e.ParamValue where e.ParamValue is not null;

  DROP field ParamValue; // so e has the same fields as flows

  return e;
}

fp_flows=applyFlowPropertyParam(flows,ScenarioID)
{
  // This function returns an augmented flows table that includes
  // a field containing the FlowFlowProperty.MeanValue field that
  // matches both FlowID and FlowPropertyID in each flows record.
  // also applies scenario-specific flow property parameterization.

  // first, determine the correct FlowFlowPropertyID
  fp_flows = SELECT flows.*,
  	     ffp.MeanValue
	     FROM flows INNER JOIN FlowFlowProperty ffp
  	     ON flows.FlowID = ffp.FlowID
	     WHERE flows.FlowPropertyID = ffp.FlowPropertyID
  
  // next, see if there are any relevant flow property params
  ParamList params = ScenarioParam.* WHERE ScenarioID = @ScenarioID
  	    	     		     AND FragmentID = @FragmentID
  fp_params = INNER JOIN params->Param->FlowPropertyParam // type 4
  
  // then attach the param values (if there are any) to fp_flows
  fp_flows = SELECT fp_flows.*,
      	     fp_params.Value AS ParamValue,
      	     FROM fp_flows 
      	     LEFT OUTER JOIN fp_params 
	     ON fp_flows.FlowFlowPropertyID = fp_params.FlowFlowPropertyID
        
  // take the param values as defaults:
  UPDATE fp_flows.MeanValue with fp_flows.ParamValue 
  	 where fp_flows.ParamValue is not null;

  DROP field ParamValue; // so e has the same fields as fp_flows

  return fp_flows;
}


Fragment.node_recurse(flows, ScenarioID, current_flow, activity)
{
  the_flow = SELECT * FROM flows WHERE FragmentNodeID = current_flow

  // "enter" the node -- handle reference property conversion
  // (params of type 4 have effect here)
  node_weight = the_node.Quantity;
  node_conv = the_node.MeanValue;

  activity = activity * node_weight * node_conv; % node activity level unit conversion

  SetNodeCache( current_flow, ScenarioID, activity )
  
  // now descend into node's children
  switch the_node.NodeType
    case 'Process'
    {
      // dependencies are encoded in the edge table
      dependencies = SELECT * FROM flows WHERE ParentFragmentFlowID = current_flow
      for i in dependencies
      { 
        node_recurse(flows, ScenarioID, i.FragmentFlowID, activity )
      }
    }
    case 'Fragment'
    { 
      // dependencies are inputs and outputs from subfragment
      the_node = SELECT * FROM the_flow INNER JOIN FragmentNodeFragment fnf
      	       	 ON the_flow.FragmentNodeID = fnf.FragmentNodeID
      
      F = new Fragment(the_flow.SubFragmentID);

      // traverse the subfragment
      F.Traverse(ScenarioID)

      // extract inputs and outputs from the subfragment
      IOFlows = F.InputOutput(ScenarioID)

      // IOFlows is a list of edges.  For every edge that has a
      // corresponding entry in our local edge table, follow it.  

      dependencies = MatchDependencies(flows,IOFlows); // not written yet

      for i in dependencies
      { 
        node_recurse(flows, ScenarioID, i.ParentFragmentFlowID, activity )
      }

    }
    case Background
      // nothing to do -- cache value specifies bg activity level

    case InputOutput
      // nothing to do -- cache value specifies input/output quantity

  end // switch NodeType
}

